{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"/Users/satansdeersatansdeer/Workspace/satansdeer.github.com/src/pages/react-native-mobx-tutorial/index.md absPath of file >>> MarkdownRemark","html":"<p><strong>Mobx</strong> is state management solution that is gaining popularity very fast. I’ll show you\nhow to create a simple <strong>React-Native</strong> app using <strong>Mobx</strong>.</p>\n<h2>What Are We Going To Build</h2>\n<p>I have a few crypto coins on some exchanges. Not like I’m trading or something, I just bought some tokens that I liked and now just hold them and buy/sell ocasionally.</p>\n<p>On <a href=\"https://www.binance.com/?ref=12930619\">Binance</a> you can see how many coins you have and what’s their worth in bitcoin and even in dollars, but you can’t see what’s the difference since the last time you’ve checked it.</p>\n<p>We are going to build portfolio tracker for it. On first run we’ll save all the coins prices and then we’ll show the difference.</p>\n<p>It’l look somewhat like this:</p>\n<p><img src=\"/assets/images/binance_tracker.png\" alt=\"binance tracker\"></p>\n<p>We’ll learn how to store data locally, use flatlist, navigator and do multi-screen applications, also we’ll learn how to manage state using mobx.</p>\n<h2>Table Of Contents</h2>\n<ol>\n<li><a href=\"#\">What is MobX</a></li>\n<li><a href=\"/posts/react-native-mobx-tutorial-part-2\">Making ReactNative app</a></li>\n<li><a href=\"#\">Testing stores</a></li>\n<li><a href=\"#\">Testing views with Enzyme</a></li>\n</ol>\n<h2>Why Mobx?</h2>\n<p>MobX is usually faster than Redux, requires less boilerplate and in general it’s easier to grasp for novice.</p>\n<p>Mobx has very few core concepts:</p>\n<ul>\n<li><a href=\"#observables\">Observables</a></li>\n<li><a href=\"#computed_values\">Computed values</a></li>\n<li><a href=\"#reactions\">Reactions</a></li>\n<li><a href=\"#actions\">Actions</a></li>\n</ul>\n<h3><a name='observables'></a>Observables</h3>\n<p>Observables allow you to subscribe for their changes. You can annotate your class properties with <code class=\"language-text\">@observable</code> decorator and then track their values with <code class=\"language-text\">observers</code>. So every time the values will change – <code class=\"language-text\">observers</code> will be updated accordingly.</p>\n<p>Here is simple example. It’s a rolling dice – every time you press <strong>ROLL</strong> button – it re-rolls the dice and displays resulting number from 1 to 6.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-html\"><code class=\"language-html\">import React, { Component } from 'react'\nimport ReactDOM from 'react-dom';\nimport { observable } from 'mobx';\nimport { observer } from 'mobx-react';\n\n@observer class Dice extends Component {\n  @observable value = 1;\n\n  render() {\n    return (\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.styles.container}</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.styles.result}</span><span class=\"token punctuation\">></span></span>Result: {this.value}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.handleRoll}</span><span class=\"token punctuation\">></span></span>ROLL<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    )\n  }\n\n  handleRoll = () => {\n    this.value = Math.floor(Math.random()*6) + 1;\n  }\n\n  styles = {\n    container: {\n      padding: '16px 0px'\n    },\n    result: {\n      fontSize: 22,\n      marginBottom: 10\n    }\n  }\n}\nReactDOM.render(<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Dice</span> <span class=\"token punctuation\">/></span></span>, document.getElementById('dice'));</code></pre>\n      </div>\n<p>\n  <div id=\"dice\"></div>\n  <script type=\"text/javascript\" src=\"/assets/javascripts/dice.js\" charset=\"utf-8\"></script>\n</p>\n<h3><a name='computed_values'></a>Computed values</h3>\n<p>Computed values can be derived from observables and will be updated automatically when the latter will be changed. Keep in mind, that in order to be updated <code class=\"language-text\">computed</code> has to be observed.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-html\"><code class=\"language-html\">@computed get computedValue() {\n  return this.value > 3 ? 'WIN' : 'LOOSE'\n}\n\nrender() {\n  return (\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.styles.container}</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.styles.result}</span><span class=\"token punctuation\">></span></span>Result: {this.value}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.styles.result}</span><span class=\"token punctuation\">></span></span>Computed Result: {this.computedValue}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.handleRoll}</span><span class=\"token punctuation\">></span></span>ROLL<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  )\n}</code></pre>\n      </div>\n<p>\n  <div id=\"computed_dice\"></div>\n  <script type=\"text/javascript\" src=\"/assets/javascripts/computed_dice.js\" charset=\"utf-8\"></script>\n</p>\n<h3><a name='reactions'></a>Reactions</h3>\n<p>Reactions are very similar to computed values but instead of returning new value they are used to produce side-effects (making network requests, patching dom e.t.c)</p>\n<p>Mobx provides 3 types of reaction functions <a href=\"https://mobx.js.org/refguide/when.html\">when</a>, <a href=\"https://mobx.js.org/refguide/autorun.html\">autorun</a> and <a href=\"https://mobx.js.org/refguide/reaction.html\">reaction</a></p>\n<ul>\n<li><code class=\"language-text\">when</code> accepts two functions: predicate and effect. It runs and observes predicate until it returns <code class=\"language-text\">true</code>, and then runs the <code class=\"language-text\">effect</code> function. After thet it disposes, and stops reacting observed property.</li>\n<li><code class=\"language-text\">autorun</code> is for cases when you need reactive function that will fire every time the observed value is updated. Unlike <code class=\"language-text\">computed</code> it doesn’t have to be observed itself.</li>\n<li><code class=\"language-text\">reaction</code> is like <code class=\"language-text\">autorun</code> but gives you more control over what properties to observe. It accepts two functions <code class=\"language-text\">data-function</code> and <code class=\"language-text\">side-effect-function</code>. <code class=\"language-text\">data-function</code> is tracked and returns data that is used in <code class=\"language-text\">side-effect-function</code>.</li>\n</ul>\n<p>Here is an example of <code class=\"language-text\">autorun</code>:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-html\"><code class=\"language-html\">constructor() {\n  super();\n  autorun(\n    ()=> (this.value > 3) &amp;&amp; alert('WIN')\n  )\n}</code></pre>\n      </div>\n<p>\n  <div id=\"reaction_dice\"></div>\n  <script type=\"text/javascript\" src=\"/assets/javascripts/reaction_dice.js\" charset=\"utf-8\"></script>\n</p>\n<h3><a name='actions'></a>Actions</h3>\n<p>Actions are anything that alters the state. So you can use them to explicitly mark that functions with <code class=\"language-text\">@action</code> decorator.</p>\n<p>This decorator takes function and wraps it into <code class=\"language-text\">transaction</code>, <code class=\"language-text\">untracked</code> and <code class=\"language-text\">allowStateChanges</code>.</p>\n<ul>\n<li><code class=\"language-text\">transaction</code> is used to batch state updates so no observers will be notified until that function is completed. So you can update multiple properties at once.</li>\n<li><code class=\"language-text\">untracked</code> allows you to run code without establishing observers (just like reactions, or unlike computed’s)</li>\n<li><code class=\"language-text\">allowStateChanges</code> is used to allow/disallow state changes for certain function. By default allows <code class=\"language-text\">action</code> to make changes (and disallows for <code class=\"language-text\">computed</code> and <code class=\"language-text\">observer</code>).</li>\n</ul>\n<h2>Observers</h2>\n<p>Strictly speaking <code class=\"language-text\">observers</code> aren’t part of mobx core. They are provided by the <code class=\"language-text\">mobx-react</code> package. But anyway…</p>\n<p>They are used to make your views “observe” <code class=\"language-text\">observables</code> and re-render on change.</p>\n<p>But I’ll cover it in next part.</p>\n<p>{% include subscription_form.html %}</p>","frontmatter":{"title":"React Native Mobx Tutorial - Part 1","date":"January 01, 2018"}}},"pathContext":{"slug":"/react-native-mobx-tutorial/","previous":{"fields":{"slug":"/react-native-e2e-tests-with-detox/"},"frontmatter":{"title":"React Native E2E Testing With Detox"}},"next":{"fields":{"slug":"/react-native-mobx-tutorial-part-2/"},"frontmatter":{"title":"React Native Mobx Tutorial - Part 2"}}}}