{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"/Users/satansdeersatansdeer/Workspace/satansdeer.github.com/src/pages/static-type-checking-js/index.md absPath of file >>> MarkdownRemark","html":"<p>We‚Äôll talk about types and static type checking in javascript. Why you might want it and how to apply it.</p>\n<h2>WAT? Javascript Has No Types</h2>\n<p><img src=\"https://media.giphy.com/media/jA8TT03Sj2pXO/giphy.gif\" alt=\"WAT\"></p>\n<p>Well, maybe I went a bit extreme. Let me explain myself.</p>\n<p>If you will search the internet for Javascript type system ‚Äì you‚Äôll find several definitions:</p>\n<h3>Javascript is</h3>\n<ul>\n<li>Dynamic</li>\n<li>Weakly typed</li>\n<li>Loosely typed</li>\n<li>Untyped</li>\n<li>Unityped</li>\n</ul>\n<p>Those definitions can be grouped into two categories:</p>\n<h3>Practical Definition</h3>\n<ul>\n<li>Dynamic</li>\n<li>Weakly typed</li>\n<li>Loosely typed</li>\n</ul>\n<p>First three definitions are the most common. And they describe the language from the practical point of view. Dynamic means that data types are bound to values and types are checked at run time.</p>\n<p>Weak/loose typing is more value, but most often it describes the fact that Javascript coerces types automatically.</p>\n<p>So Javascript allows you to do all kinds of crazy stuff with your values:</p>\n<h2>Unityped/Untyped</h2>\n<p>This notion is more common in academic circles.</p>\n<p>Here I‚Äôll refer to the definition of Benjamin Pierce book ‚ÄúTypes and Programming Languages‚Äù where he gives the following definition of the type system.</p>\n<blockquote>\n<p>A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.</p>\n</blockquote>\n<p>Ok, I hope that I look smart now ü§ì.</p>\n<p>And basically, this phrase means that type system allows to check the syntax of the program and mark some phrases invalid if kinds of values it computes don‚Äôt align.</p>\n<p>The fact that we can tell it just by the syntax ‚Äì means that we do it statically, not at runtime.</p>\n<p>In javascript there is no way to say that some values won‚Äôt align, all of that expressions are valid:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\"</span>\n<span class=\"token boolean\">true</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span></code></pre>\n      </div>\n<p>This is what I meant by saying that Javascript has no types.</p>\n<p>From practical perspective it has types, but it has them only at runtime, and even at runtime it implicitly coerces them.</p>\n<h2>Small Conclusion</h2>\n<p>Javascript is dynamic, does all type checks at runtime, and even then tries to coerce types implicitly, so you wouldn‚Äôt have to worry about it.\nYou can write syntactically correct programs where you‚Äôll perform operations on incompatible things and you‚Äôll know this only at runtime.</p>\n<p>Now let‚Äôs discuss why you might want to add static type checking.</p>\n<h2>WHY, Do we need static type checking?</h2>\n<h3>The problem of complexity</h3>\n<p>Programming is hard. And the longer you develop some program ‚Äì the harder it becomes.</p>\n<p>Probably everyone has noticed that <strong>it‚Äôs always easier to develop new projects</strong> than support old ones. That‚Äôs because of complexity that tends to grow pretty fast as we add new features to the program.</p>\n<h3>Separating by units</h3>\n<p>So we break our programs into smaller parts. It can be functions, modules, classes. Doesn‚Äôt matter as long as we break our big project into smaller chunks.</p>\n<p>And then we cover those smaller parts with tests. This is great, now we can make sure that our units work as intended. We have delightful islands of control in our sea of entropy.</p>\n<p>But there still are parts that we can‚Äôt cover with unit tests.</p>\n<h3>Spaces in between</h3>\n<p>Those are spaces in between. The spaces where our units interact with each other.</p>\n<p>How do we test those? Well, the most obvious solution would be to take those units that have to work together and test them in integration. But this is unsustainable, and you‚Äôll never be able to tell if you covered all the use cases. And the more modules and their combinations you have ‚Äì the more prominent this problem becomes.</p>\n<p>Another way to ensure that your units will work together ‚Äì is by defining contracts, and then enforcing them. </p>\n<p>And here is where Javascript dynamic nature doesn‚Äôt help us at all. You can pass any values to your functions ‚Äì and you‚Äôll be able to catch errors only at runtime.</p>\n<img style=\"max-width: 300px\" src=\"http://gifgifmagazine.com/wp-content/uploads/2018/03/brokula-pica-i-pas.gif\">\n<p>In React world there is a very popular way to do it ‚Äì the PropTypes. But it‚Äôs a runtime check, so you might see some errors late and also it‚Äôs applicable only to react components.</p>\n<p>There is a better solution. We can add static type checking to Javascript. For example with Flow.</p>\n<h2>Flow</h2>\n<p>Flow is a static type checker made by Facebook. It‚Äôs pretty easy to start using. Just install the <code class=\"language-text\">npm</code> package:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\">yarn add <span class=\"token operator\">--</span>dev flow<span class=\"token operator\">-</span>bin</code></pre>\n      </div>\n<p>Run <code class=\"language-text\">yarn run flow init</code> and then just run <code class=\"language-text\">yarn run flow</code> to check your project for type errors.</p>\n<p>I recommend using comments for flow type annotations. Flow has it‚Äôs own comments syntax, to use it add a double colon in the beginning of the comments block.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/*::\ntype Foo = {\n  foo: number,\n  bar: boolean,\n  baz: string\n};\n*/</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*:: prop: string; */</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>You can also use <code class=\"language-text\">flow-include</code> instead of double colon:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/*flow-include\ntype Foo = {\n  foo: number,\n  bar: boolean,\n  baz: string\n};\n*/</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*flow-include prop: string; */</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>And here is what it allows you to do.</p>\n<h3>Catch errors early</h3>\n<p>You can add flow support to your editor and get hints as you develop. It has plugins for most popular editors:</p>\n<ul>\n<li>Atom</li>\n<li>Sublime Text</li>\n<li>Vim</li>\n<li>Emacs</li>\n<li>Visual Studio Code</li>\n<li>WebStorm </li>\n</ul>\n<p>It will be much easier to refactor your code. Now you‚Äôll instantly know that you‚Äôve changed the contract of your unit ‚Äì and you‚Äôll be able to fix it faster.</p>\n<h3>Inferring Types</h3>\n<p>Flow will infer types. What does it mean? Some good news, you don‚Äôt need to always write type annotations. Where possible ‚Äì flow will try to infer types automatically.</p>\n<p>Here is an example:</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// @flow</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Works!</span>\n<span class=\"token comment\">// $ExpectError</span>\n<span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Error!</span></code></pre>\n      </div>\n<h3>Literal, Union, Intersection, Interface</h3>\n<p>Now you can be very specific with kinds of values your functions accept. You can limit it to nominal types, literals, or even structural types, using interfaces.</p>\n<p>Actually, I was lacking interfaces in javascript for a long time. Now you can the define some interface and ensure that only objects that conform to it (have all required methods and properties) will be accepted in some function.</p>\n<p>Also you can list allowed values for your function. <code class=\"language-text\">function getColor(name: &quot;success&quot; | &quot;warning&quot; | &quot;danger&quot;)</code>.</p>\n<p>It‚Äôs a lot more powerful than what <code class=\"language-text\">PropTypes</code> can provide.</p>\n<h2>Conclusion And My Thoughts</h2>\n<p>Static type checking is a very powerful instrument. It allows preventing bugs by defining clear contracts for your units of code. It adds some noise when you read and you have to type (pun intended) a bit more. </p>\n<p>In this article, I used Flow as an example of static type checking tool. There are others, you can use TypeScript, Elm, ReasonML e.t.c.</p>\n<p>My main point is that static type checking will help you to ensure that your modules conform the contract and that you use them properly. If you have poor architecture, or your modules are not covered by unit tests ‚Äì static type checking won‚Äôt help you.</p>\n<h2>Free React Course</h2>\n<p>I‚Äôve released a <code class=\"language-text\">WIP</code> version of my <a href=\"https://basicreact.com\">React Course</a>, check it out.</p>\n<p>I really wan to make it useful, so join the <a href=\"https://join.slack.com/t/frontendartisans/shared_invite/enQtMzM1MjM3ODYyMDY1LWUwYzM4ZDc5ZDU1MjY1ZWM2OWZmNWUzZmZlNGJhOGRiYzA1ZmFiZDBkZDg2YmI3MzMyNTcxODVhZjgzMjNiZjc\">Slack Channel</a> and let me know what you‚Äôd like to see in <strong>your perfect react course</strong>.</p>","frontmatter":{"title":"Do You Need Static Type Checking?","date":"April 08, 2018"}}},"pathContext":{"slug":"/static-type-checking-js/","previous":{"fields":{"slug":"/gradient-coin-tutorial-part-3/"},"frontmatter":{"title":"CryptoKitties Clone Part 3 Adding Frontend"}},"next":false}}