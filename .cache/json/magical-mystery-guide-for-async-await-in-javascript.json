{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"/Users/satansdeersatansdeer/Workspace/satansdeer.github.com/src/pages/magical-mystery-guide-for-async-await-in-javascript/index.md absPath of file >>> MarkdownRemark","html":"<p>Hey there! Today we are going to look at <strong>async</strong> and <strong>await</strong> keywords that allow you to pause functions execution, and therefore let you write <strong>asynchronous</strong> code that reads like <strong>synchronous</strong>.</p>\n<p>But first let’s go through other ways of dealing with asynchronicity in javascript. You know, just to make you <strong>appreciate</strong> how async/await allows you to write more readable asynchronous code.</p>\n<h2>First We Had Callbacks</h2>\n<p>Imagine that we have some <strong>MagicalWorldAPI</strong>, and we need to get a list of quests of the hero of some imaginary world.</p>\n<p>With callbacks it would look somewhat like this.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">getWorld</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> world<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// handle error;  </span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">getHero</span><span class=\"token punctuation\">(</span>world<span class=\"token punctuation\">.</span>heroId<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> hero<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//handle error;  </span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">getQuests</span><span class=\"token punctuation\">(</span>hero<span class=\"token punctuation\">.</span>questsIds<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> quests<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//handle error;  </span>\n        <span class=\"token keyword\">return</span>\n      <span class=\"token punctuation\">}</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>quests<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>Doesn’t look very good, right? A lot of nesting, also you have to handle errors separately in every callback and it’s kinda error prone. You might forget to add a return statement after you’ve handled an error, or do another silly mistake.</p>\n<p>Can we improve this? </p>\n<h2>Yes, With Promises</h2>\n<p>Let’s imagine that our <strong>MagicalWorldAPI</strong> was updated and now it returns <code class=\"language-text\">Promise</code> objects. Let’s adapt to it.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">getWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>world<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">getHero</span><span class=\"token punctuation\">(</span>world<span class=\"token punctuation\">.</span>heroId<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>hero<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">getQuests</span><span class=\"token punctuation\">(</span>hero<span class=\"token punctuation\">.</span>questsIds<span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>quests<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>quests<span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//handle error</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>Now we have a callback in <code class=\"language-text\">catch</code> function where we can handle errors from any part of that chain. Better, but the code is still hard to read. If only we could make it look synchronous…  </p>\n<h2>Async/Await? Not yet, generators</h2>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> world <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> hero <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getHero</span><span class=\"token punctuation\">(</span>world<span class=\"token punctuation\">.</span>heroId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> quests <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">getQuests</span><span class=\"token punctuation\">(</span>hero<span class=\"token punctuation\">.</span>questsIds<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>quests<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//handle error  </span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre>\n      </div>\n<p>Ok, the part where we use our imaginary <strong>API</strong> looks nice now, but the other code is cryptic! What does that <code class=\"language-text\">*</code> in function declaration do and what are those <code class=\"language-text\">yield</code> statements?</p>\n<p>The asterisk after the <code class=\"language-text\">function</code> statement makes it create a <strong>generator function</strong> and the <code class=\"language-text\">yield</code> keyword pauses <strong>generator function</strong> execution and the value of the expression following the <code class=\"language-text\">yield</code> keyword is returned to the generator’s caller. </p>\n<p>And <code class=\"language-text\">co</code> is a nice function that can resolve a <strong>generator function</strong> and return a promise. </p>\n<p>So in this example, the <code class=\"language-text\">getWorld()</code> returns a promise. Then <code class=\"language-text\">yield</code> pauses further execution of our star signed function and passes the result of <code class=\"language-text\">getWorld()</code> to the <code class=\"language-text\">co</code> function. The <code class=\"language-text\">co</code> function takes the promise, resolves it and passes the value back to the generator function where it is being assigned to the <code class=\"language-text\">world</code> variable.</p>\n<p>Then the same is repeated for other variables.</p>\n<h2>Finally we are getting to async/await</h2>\n<p>Let’s rewrite our code once more.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> world <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> hero <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getHero</span><span class=\"token punctuation\">(</span>world<span class=\"token punctuation\">.</span>heroId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> quests <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getQuests</span><span class=\"token punctuation\">(</span>hero<span class=\"token punctuation\">.</span>questsIds<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>quests<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//handle error</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>Looks familiar, right? We just changed <code class=\"language-text\">yield</code> to <code class=\"language-text\">await</code>, instead of <code class=\"language-text\">fuction*</code> we now have <code class=\"language-text\">async function</code> statement and we don’t use the <code class=\"language-text\">co</code> function here.</p>\n<p>Oh, and another thing, we now use the <code class=\"language-text\">try/catch</code> to handle errors. This is good, because we can now handle both sychronous and asynchronous code errors the same way.</p>\n<p><strong>So what happens here?</strong></p>\n<p>The <code class=\"language-text\">async function</code> statement defines an <strong>asynchronous function</strong>. When an <strong>async function</strong> is called, it returns a Promise. When the <strong>async function</strong> returns a value, the <code class=\"language-text\">Promise</code> will be resolved with the returned value. When the <strong>async function</strong> throws an exception, the <code class=\"language-text\">Promise</code> will be rejected.</p>\n<p>Also an <strong>async function</strong> can contain an <code class=\"language-text\">await</code> expression, that pauses the execution of the async function and waits for the passed Promise’s resolution, and then resumes the <strong>async function’s</strong> execution and returns the resolved value.</p>\n<p>The execution flow will go a lot like in previous example. When we’ll stumble upon the first <code class=\"language-text\">await</code> statement – our <strong>async function</strong> will get paused until the <code class=\"language-text\">getWorld()</code> promise will be resolved. Then <strong>async function</strong> will get unpaused and the resolved value will be assigned to the <code class=\"language-text\">world</code> variable.</p>\n<p>Then the same will be repeated for other varibales.</p>\n<h2>Summary</h2>\n<p>Today we’ve learned that using <code class=\"language-text\">async</code> statement you can create <strong>asynchronous function</strong>.</p>\n<p>Inside that function you can use the <code class=\"language-text\">await</code> statement in front of expression that returns a <code class=\"language-text\">Promise</code>.</p>\n<p>When the <strong>async function</strong> will by executed, it will pause just where the <code class=\"language-text\">await</code> statement is until that <code class=\"language-text\">Promise</code> is resolved.</p>\n<p>And also we’ve learned that using <code class=\"language-text\">async/await</code> you can simplify reading of an asynchronous code by giving a more synchronous flow to it.</p>\n<p>{% include subscription_form.html %}</p>","frontmatter":{"title":"Magical Mystery Guide For Async/Await In Javascript","date":"September 28, 2017"}}},"pathContext":{"slug":"/magical-mystery-guide-for-async-await-in-javascript/","previous":false,"next":{"fields":{"slug":"/getting-schwifty-with-pull-requests/"},"frontmatter":{"title":"Getting Schwifty With Pull Requests"}}}}